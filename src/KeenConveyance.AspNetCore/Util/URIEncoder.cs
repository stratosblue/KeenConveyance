// <Auto-Generated/>

using System.Runtime.InteropServices;

namespace KeenConveyance.Util;

internal unsafe static class URIEncoder
{
    //HACK random padding
    private static readonly byte s_paddingSeed1 = (byte)(Environment.TickCount >> 1);

    private static readonly byte s_paddingSeed2 = (byte)(Environment.TickCount >> 5);

    private static readonly byte* s_charactersPtr;
    private static readonly byte* s_reverseCharactersPtr;

    static URIEncoder()
    {
        s_charactersPtr = URIEncoderData.CharactersPtr;
        s_reverseCharactersPtr = URIEncoderData.ReverseCharactersPtr;
    }

    public static byte[] Decode(in ReadOnlySpan<byte> data)
    {
        if (data.Length % 4 != 0)
        {
            throw new ArgumentException("input length error.", nameof(data));
        }

        var inputLength = data.Length;
        var blockCount = inputLength / 4;
        var outputLength = blockCount * 3;

        byte source1, source2, source3, source4;

        var output = new byte[outputLength];
        fixed (byte* sourcePtr = data)
        fixed (byte* outputPtr = &output[0])
        {
            unchecked
            {
                for (int i = 0, j = 0; i < inputLength; i += 4, j += 3)
                {
                    source1 = s_reverseCharactersPtr[sourcePtr[i]];
                    source2 = s_reverseCharactersPtr[sourcePtr[i + 1]];
                    source3 = s_reverseCharactersPtr[sourcePtr[i + 2]];
                    source4 = s_reverseCharactersPtr[sourcePtr[i + 3]];

                    outputPtr[j] = (byte)((source1 << 2) | ((source2 & 0b_0011_0000) >> 4));
                    outputPtr[j + 1] = (byte)(((source2 & 0b_1111) << 4) | ((source3 & 0b_1111_1100) >> 2));
                    outputPtr[j + 2] = (byte)(((source3 & 0b_0011) << 6) | source4);
                }
            }
        }

        return output;
    }

    public static byte[] Encode(in ReadOnlySpan<byte> data)
    {
        if (data.IsEmpty)
        {
            return Array.Empty<byte>();
        }

        var inputLength = data.Length;
        var padding = inputLength % 3;
        return padding != 0
               ? PaddingEncode(data, inputLength, padding)
               : NoPaddingEncode(data, inputLength);
    }

    public static string EncodeAsString(in ReadOnlySpan<byte> data)
    {
        var result = Encode(data);
        fixed (byte* resultPtr = &result[0])
        {
            var sbytePtr = (sbyte*)resultPtr;
            return new string(sbytePtr, 0, result.Length);
        }
    }

    internal static byte[] InternalEncode(in byte* sourcePtr, in int blockCount, in int outputLength)
    {
        byte source1, source2, source3;

        var output = new byte[outputLength];
        fixed (byte* outputPtr = &output[0])
        {
            unchecked
            {
                for (int i = 0, j = 0; i < blockCount * 3; i += 3, j += 4)
                {
                    source1 = sourcePtr[i];
                    source2 = sourcePtr[i + 1];
                    source3 = sourcePtr[i + 2];

                    outputPtr[j] = s_charactersPtr[(source1 & 0b_1111_1100) >> 2];
                    outputPtr[j + 1] = s_charactersPtr[((source1 & 0b_0011) << 4) + ((source2 & 0b_1111_0000) >> 4)];
                    outputPtr[j + 2] = s_charactersPtr[((source2 & 0b_1111) << 2) + ((source3 & 0b_1100_0000) >> 6)];
                    outputPtr[j + 3] = s_charactersPtr[source3 & 0b_0011_1111];
                }
            }
        }

        return output;
    }

    private static byte[] NoPaddingEncode(in ReadOnlySpan<byte> data, in int inputLength)
    {
        var blockCount = inputLength / 3;
        var outputLength = blockCount * 4;
        fixed (byte* sourcePtr = data)
        {
            return InternalEncode(sourcePtr, blockCount, outputLength);
        }
    }

    private static byte[] PaddingEncode(in ReadOnlySpan<byte> data, int inputLength, in int padding)
    {
        inputLength += padding;
        var blockCount = inputLength / 3;
        var outputLength = blockCount * 4;

        var sourcePtr = stackalloc byte[inputLength];
        Span<byte> source = new(sourcePtr, inputLength);

        source[--inputLength] = s_paddingSeed2;

        if (padding != 1)
        {
            source[--inputLength] = s_paddingSeed1;
        }

        data.CopyTo(source);

        return InternalEncode(sourcePtr, blockCount, outputLength);
    }

    private static class URIEncoderData
    {
        private static readonly byte[] s_characters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-0123456789"u8.ToArray();

        public static byte* CharactersPtr { get; }

        public static byte* ReverseCharactersPtr { get; }

        static URIEncoderData()
        {
            var length = s_characters.Length;
            var charactersPtr = (byte*)Marshal.AllocHGlobal(length);
            var reverseCharactersPtr = (byte*)Marshal.AllocHGlobal(byte.MaxValue);

            for (int i = 0; i < length; i++)
            {
                if (i % 2 == 0)
                {
                    charactersPtr[i] = s_characters[i];
                }
                else
                {
                    charactersPtr[i] = s_characters[(i + length / 2) % length];
                }
            }

            for (byte i = 0; i < length; i++)
            {
                reverseCharactersPtr[charactersPtr[i]] = i;
            }

            CharactersPtr = charactersPtr;
            ReverseCharactersPtr = reverseCharactersPtr;
        }
    }
}
